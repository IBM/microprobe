# RISC-V Microprobe Examples

## For single instruction testcases

```bash
./riscv_ipc.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA] [--uarch UARCH]
                    [--env ENV]
                    [--dependency-distances DEPENDENCY_DISTANCES [DEPENDENCY_DISTANCES ...]]
                    [--instructions INSTRUCTIONS [INSTRUCTIONS ...]]
                    [--loop-size LOOP_SIZE]


## For a sequence of instructions
```bash
./riscv_ipc_seq.py [-h] [--output-dir OUTPUT_DIR] [--isa ISA]
                        [--uarch UARCH] [--env ENV]
                        [--dependency-distances DEPENDENCY_DISTANCES [DEPENDENCY_DISTANCES ...]]
                        [--instructions INSTRUCTIONS [INSTRUCTIONS ...]]
                        [--loop-size LOOP_SIZE]
                        [--num_permutations NUM_PERMUTATIONS]
                        [--microbenchmark_name MICROBENCHMARK_NAME]

autoconf
mkdir build
cd build
../configure --with-riscvtools=$RISCV_TOOLS_DIRECTORY
make
```

## Instructions

The structure of this example is modeled off of [riscv-tests](https://github.com/riscv/riscv-tests).
However, the underlying tests are generated by Microprobe.

For this example, we explore variations in RAW dependency distance.
By dependency distance, we mean the distance (in terms of _number of instructions_) between which a register result is produced and it is consumed.
The following sequence of instructions has a dependency distance of 1:

```asm
ADD x10, x9, x5
ADD x12, x11, x10
ADD x14, x13, x12
```

Each instruction produces a result that is needed by the next instruction, e.g., `x10` is produced by the first instruction and consumed by the second.
The following sequence has a dependency distance of 2:

```asm
ADD x11, x10, x9
ADD x13, x12, x5
ADD x15, x14, x11
```

Here, `x11` is produced by the first instruction and consumed by the _third_.

The included program `riscv_ipc.py` will produce microbenchmarks that have different dependency distances.
Go ahead and run this now with `./riscv_ipc.py`.
This produces a number of benchmarks in `riscv_ipc/`, e.g., `ADD_V0_1.S` and `ADD_V0_2.S` that produce assembly sequences like those shown above.
Additionally, this produces a Makefile fragment, `tests.d`, that describes all the microbenchmarks that were generated.
The provided build flow will consume this later.

The program `riscv_ipc_seq.py` is used if we need to generate microbenchmarks containing a sequence of instructions. It generates N microbenchmarks comprising of different randomly selected permutations of the instruction sequence specified, where N is specified by the optional argument: `num_permutations`. By default this value is 1, which generates a single randomly selected permutation of the instruction sequence.
 
Now, we need to setup an out-of-source build environment.
These microbenchmarks depend on a number of header files provided by [`riscv-tests`](https://github.com/riscv/riscv-tests) and [`riscv-test-env`](https://github.com/riscv/riscv-test-env).
Hence, when configuring the project, we need to provide a path to an existing clone of `riscv-tools`, represented by the bash variable `$RISCV_TOOLS_DIRECTORY` (substitute in a real path here!)

```bash
autoconf
mkdir build
cd build
../configure --with-riscvtools=$RISCV_TOOLS_DIRECTORY
```

You need to have a suitable RISC-V cross compiler (specifically `riscv64-unknown-elf-gcc`) available on your path to compile the microbenchmarks.
You can then run `make` to compile all the Microprobe generated microbenchmarks int `build/riscv_ipc/`.

These can then be run on suitable RISC-V hardware or in a simulation/emulation environment, e.g., :

```
spike riscv_ipc/riscv_ipc-p-ADD_V0_1
```
